1.复杂度分析：

    大前提：假设每个语句的执行时间都是unit_time

    结论：所有代码的执行时间和每行代码的执行次数成正比

    提出概念：大O时间复杂度表示法（渐进时间复杂度），   代码执行时间随数据规模增长的变化趋势

2.推论
    只关注循环执行次数最多一段段代码

    总复杂度等于量级最大的那段代码的复杂度

    嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

3.复杂度量级：多项式量级和非多项式量级

多项式量级：常量阶、对数阶、线性阶、线程对数阶、平方阶

非多项式量级：指数阶、阶乘阶

eg.

对数阶：

i=1;
while(i<=n)
i=i*2;


有俩个数据规模的复杂度分析

渐进时间复杂度：表示算法的执行时间与数据规模之间的增长关系

渐进空间复杂度：算法的存储空间和数据规模之间的增长关系

4.最好情况时间复杂度和最坏情况时间复杂度和平均时间复杂度和均摊时间复杂度

均摊时间复杂度：对一个数据结构进行一组连续操作时，大部分情况下时间复杂度 
都很低，只有个别情况时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系。


5.数组：线性表、连续的内存空间和相同类型的数据

数组的插入：按顺序的插入、不按顺序的插入

数组的删除：标记删除（将多次删除合并）

对于业务开发，一般直接使用容器即可；如果是比较底层的开发，数组则由于容器。

例如ArrayList无法存储基本类型，box和unbox需要耗费时间，容器尽量指定初始化大小

6.链表：

缓存淘汰策略：FIFO、LFU、LRU

单链表、循环链表、双向链表、循环双向链表

单链表、双链表插入时效率问题？？？？

数组和链表的对比：数组使用连续的内存空间，可以借助CPU的缓存机制

对链表的插入和删除，容易造成内存碎片;数组扩容时耗费更多时间

使用数组和链表实现LRU算法、实现回文字符串算法

单链表反转、链表中环的检测、有序链表合并、删除链表倒数第n个节点、求链表的中间节点

链表中哨兵节点的概念

7.栈：

顺序栈，扩容问题，复杂度分析

链式栈

栈在函数调用中的应用

栈在表达式求值中的应用

栈在括号匹配中的应用

栈实现前进后退的功能

8.队列：

顺序队列：扩容的问题，循环队列的问题

链式队列：


9.递归：

一个问题解可以分解为几个子问题的解

问题和分解后的子问题，除了数据规模，求解思路完全一样

存在递归终止条件

递归存在的问题：堆栈溢出、重复计算

10.排序：冒泡、插入、选择；快排、归并；桶排序、计数排序、基数排序

排序算法的执行效率：比较次数和交换次数；时间复杂度的系数、常数、低阶；最好、最坏、平均时间复杂度

排序算法的内存消耗：

排序算法的稳定性：订单排序例子

冒泡排序：

逆序度=满有序度-有序度

冒泡排序含有两个操作原子：比较和交换，交换次数总是确定的（逆序度）

插入排序：优化（希尔排序）

选择排序：

以上三种排序算法适用于小规模

归并排序和快速排序适用于大规模，都用到了分治思想

归并排序：

快速排序：

线性排序：非基于比较的排序算法，桶排序等，但是一般对数据有严格的特征要求

桶排序：

计数排序：

基数排序：？？？？

排序优化：

如果实现一个通用的排序函数，线性排序函数的时间复杂度虽然比较低

但是适用场景特殊。java中采用堆排序实现排序函数，c中综合了多种排序算法

如何优化快排，分区点的选择方案（三数取中、随机）

11.二分查找：针对的是一个有序集合、依赖顺序表结构

二分查找的变体：

查找第一个值等于给定值的元素

查找最后一个值等于给定值的元素

查找第一个大于等于给定值的元素

查找最后一个小于或等于给定值的元素

12.跳表：链表添加多级索引，可以实现链表形式的二分查找

跳表的插入和删除：删除时需要删除索引

也需要动态更新索引，插入的使用使用随机函数选择将节点同步到第几层

索引，避免退化

13.散列表：利用数组按照下标随机访问数据的特性

真实的情况中，要想找到一个不同的key对应的散列值都不一样的散列函数，

几乎是不可能的，像业界的MD5、SHA、CRC等哈希算法，也无法完全避免散列冲突

而且因为数组空间有限，也会加大散列冲突的概率

解决散列冲突的方法：

开发寻址法：线性探测（在删除时不能将数据真正的删除）、二次探测、双重散列

为了尽可能减少hash冲突，需要尽可能保证散列表中有一定比例的空闲槽位（装载因子）

散列表的装载因子=填入表中元素个数/散列表长度？？？？？？

链表法：更加常用

利用散列表实现word文档的单词拼写检查

散列表来源于数组，借助散列函数对数组这种数据结构进行扩展，利用的是数组支持按照

下标随机访问元素的特性。散列表的两个核心问题：散列函数设计和散列冲突解决。

设计一个可以应对各种异常情况的工业级散列表，来避免在散列冲突的情况下，散列表性能

急剧下降，并且能够抵抗散列碰撞攻击。

如何设计散列函数：不能太复杂，生成的值要尽可能随机并且均匀分布。实际工作中，还需要

综合考虑各种因素，如关键字长度、特点、分布。

装载因子过大怎么办：针对散列表的扩容需要进行重新映射

当删除散列表的内容，可以进行动态缩容

如何避免低效的扩容：一次性扩容搬移数据有时候不合适，可以维护一个扩容后的新散列表，每次插入时

将就散列表中内容复制过去，这期间的查询操作需要参考两个散列表中内容

解决散列冲突两种方案的比较：

开放寻址法：可以有效利用CPU缓存，序列化简单。数据量较小，装载因子较小时，ThreadLocalMap

链表法：比较适合存储大对象、大数据量，它更加灵活，支持更多的优化策略

jdk8中对hashmap做了优化，当链表长度过长（默认超过8），链表就转换为红黑树

Redis中的有序集合就是用跳表来实现的

14.哈希算法：

将任意长度的二进制值串映射为固定长度的二进制值串，这个映射规则就算哈希算法

从hash值不能反向推导出原始数据

对输入数据敏感

散列冲突的概率要小

执行效率要高效

哈希算法的应用：

安全加密--最长用于加密的哈希算法，MD5（消息摘要算法）、SHA（安全散列算法）

唯一标识--

数据校验--

散列函数--

负载均衡--需要在同一个客户端上，在一次会话中的所有请求都路由到同一个服务器上。可以

通过hash算法，对客户端ip地址或者会话id计算哈希值，将取得的哈希值与服务器列表的大小

进行取模运算，最终得到的值就是应该被路由到的服务器编号。

数据分片--“搜索关键词次数”、“如何快速判断图片是否在图床中”

分布式存储--使用哈希算法进行计算内容存在的机器，如果增加机器，所有的数据都要重新计算哈希值

，然后重新搬移到正确的机器上，这样缓存中的数据就都失效了。所有的数据都会穿透缓存，这就可能

发生雪崩效应，压垮数据库。一致性哈希算法就是为了应对这种情况。

一致性哈希提出在动态变化的cache环境中，哈希算法应该满足4个适应条件，均衡性、单调性、分散性、负载

环形hash

15.树：

节点的高度：节点到叶子节点的最长路径（边数）

节点的深度:根节点到这个节点的所经历的边的个数

节点的层数：节点的深度+1

树的高度：根节点的高度




二叉树--最常用，左子节点、右子节点，并不要求每个节点都有这两个节点 

满二叉树：叶子节点全在最底层，除叶子节点之外，每个节点都有左右两个节点

完全二叉树：叶子节点都在最底下两层，最后一层的叶子节点都靠左，并且除了最后，其他层的节点个数要达到最大。

存储二叉树：基于指针或者引用的二叉链式存储法，一种是基于数组的顺序存储法。

如果完全二叉树，数组是最适宜的存储方式，堆起始就是一种完全二叉树。

卡兰特数：

二叉树的遍历：前序遍历、中序遍历、后序遍历，是一个递归的过程，把遍历抽象为一个过程

层序遍历




二叉查找树：支持动态数据的快速插入、删除、查找操作

任意一个节点，其左子树节点需要小于此节点，右子节点需要大于此节点

支持重复数据的二叉查找树：类似哈希表的方式；对于相同的数据放在右子树？？？


平衡二叉查找树：最先被发明的是AVL树，严格符合平衡二叉查找树的特点

而红黑树则没有严格符合定义要求，发明平衡二叉查找树的初衷时，解决普通二叉查找树

在频繁的插入、删除等动态更新的情况下，出现时间复杂度退化的现象。

平衡二叉查找树其实很多，比如，伸展树、树堆、红黑树等

R-B Tree？？？？？？？？


16.排序算法的比较

排序算法的执行效率：

    最好、最坏、平均时间复杂度

    时间复杂度的系数、常数、低阶

    比较次数和交换次数

排序算法的内存消耗：原地排序

排序算法的稳定性：稳定性

复杂度n的平方的排序算法：

冒泡排序：

有序度、无序度的概念

分为两个区间：后面为有序的区间，前面无序区间通过两两比较，得出无序区间最大的一个数，然后追加到有序区间。

原地排序，稳定的排序算法

插入排序:

冒泡是从无序区间一个个找出最大的排列，插入则是处理有顺序的处理无序区间的元素，维持有序区间的有序度

希尔排序？？？？

选择排序：是否是原地排序？？？？


归并排序：分治思想  递归处理技巧 类似二叉树的不断分支

复杂度nlogn，是不是原地排序取决于merge操作，不是原地排序

快速排序：递归的进行分区，直到不能分区为止（对其进行的优化，如何选择分区点）

快排为什么不是稳定的？？？出现了与pivot相同元素，必须确定这个元素的区间，因此是不稳定的

二分查找：时间复杂度为logn,依靠有序线性表

如果出现重复元素，在进行迭代过程中需要考虑迭代的是第几个重复元素

找到指定第一个的元素、找到指定的最后一个元素、找到第一个大于或等于某个元素、找到最后一个大于或等于某个元素

二分查找常用于近似查找！！！！！！！！

循环数组的二分查找？？？？

跳表：redis的有序集合   动态数据结构？？？？

对有序链表建立索引，关键在于索引的建立与更新

散列表：

散列函数设计的要点：散列值是一个非负整数、如果key1==key2则hash值相同、反之

解决哈希的冲突的方法：

开放寻址法：线性探测、二次探测、双重散列

装载因子=填入表中的元素个数/散列表长度

链表法：

如何设计散列函数：设计不能太复杂、生成的值尽可能随机并且均匀分布

散列表进行扩容时，需要对所有存储条目进行rehash

如果一次性扩容，某次服务可能很慢：达到某个阈值之后，重新申请一个扩容的空闲散列表，之后每次插入元素到

新散列表中时，将其中一部分内容搬移到新散列表中

除留余数法？？？？

散列表和数组的结合使用：LRU算法、redis中set

哈希算法：不能反向反向推导出数据、对数据输入敏感、高效、散列冲突概率要小

哈希算法的应用：

安全加密、唯一标识、数据校验、散列函数、负载均衡、数据分片、分布式存储（一致性哈希？？？？？）




-----------------------------------《算法通关40讲》-----------------------------------

有效的学习数据结构与算法：

《异类-不一样的成功启示录》

chunk it up    

deliberate practice

feedback

斐波那契数列的时间复杂度

LeetCode

https://www.bigocheatsheet.com/


优先队列的实现机制：Heap（Binary，Binomial，Fibonacii）、Binary Serach Tree

Heap的多种实现机制：

优先队列的应用：https://www.cnblogs.com/wmyskxz/p/9301021.html


Hash Function,如何解决hash冲突

HashMap vs TreeMap

HashSet vs TreeSet

(HashSet vs binary-search-tree)

树：LinkedList就是特殊化的Tree，Tree就是特殊化的Graph

二叉树

二叉搜索树：左子树节点<根节点<右子树节点、左右子树分别为二叉搜索树

98  235   236

二叉树遍历：程序中使用较少

递归和分治：
